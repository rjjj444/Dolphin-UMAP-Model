#Generating UMAP timeshift #02B

# Suppress warnings
import warnings
warnings.filterwarnings('ignore', category=UserWarning)

#Import statements, constants and functions
import pandas as pd
import numpy as np
import pickle
import os
from pathlib import Path
import umap
import sys 
sys.path.insert(0, '..')

from functions.preprocessing_functions import calc_zscore, pad_spectro, pad_transform_spectro
from functions.custom_dist_functions_umap import unpack_specs
import numba

#Use your correct paths
P_DIR = r"C:\Users\rjjne\OneDrive\Desktop\avgn_paper\avgn_paper_subfolder"
DATA = os.path.join(P_DIR, 'data')

print("="*70)
print("UMAP WITH TIME-SHIFT")
print("="*70)

#Specify UMAP parameters
INPUT_COL = 'spectrograms'
MIN_OVERLAP = 0.9
METRIC_TYPE = 'euclidean'
N_COMP = 3

print(f"\nParameters:")
print(f"  Input column: {INPUT_COL}")
print(f"  Minimum overlap: {MIN_OVERLAP} ({MIN_OVERLAP*100}%)")
print(f"  Distance metric: {METRIC_TYPE}")
print(f"  Number of components: {N_COMP}")

#############################
#1. Load data
print("\n" + "="*70)
print("STEP 1: Loading Data")
print("="*70)
df_path = os.path.join(DATA, 'df.pkl')
print(f"Loading from: {df_path}")
df = pd.read_pickle(df_path)
print(f"✓ Loaded {len(df)} samples with {len(df.columns)} columns")

#############################
#2. UMAP

print("\n" + "="*70)
print("STEP 2: Setting Up Time-Shift Distance Function")
print("="*70)

#2.1. Load custom distance function with time-shift

# Pipeline with allowing for time-shift of spectrograms. When assessing distance between spectrograms,
# the shorter spectrogram is shifted along the longer one to find the position of minimum-error overlap.
# The shorter is then zero-padded to the length of the longer one and distance is calculated using the 
# chosen METRIC_TYPE distance (euclidean, manhatten, cosine, correlation)
# This also means that the dimensionality of the spectrogram vectors can be different for each pairwise 
# comparison. Hence, we need some sort of normalization to the dimensionality, otherwise metrics like 
# euclidean or manhattan will automatically be larger for high-dimensional spectrogram vectors (i.e. calls
# with long duration). Therefore, euclidean and manhattan are normalized to the size of the spectrogram.

print(f"Creating custom distance function for metric: {METRIC_TYPE}")

if METRIC_TYPE=='euclidean':
    @numba.njit()
    def spec_dist(a,b,size):
        dist = np.sqrt((np.sum(np.subtract(a,b)*np.subtract(a,b)))) / np.sqrt(size)
        return dist
    print("✓ Using Euclidean distance (normalized)")
    
elif METRIC_TYPE=='manhattan':
    @numba.njit()
    def spec_dist(a,b,size):
        dist = (np.sum(np.abs(np.subtract(a,b)))) / size
        return dist
    print("✓ Using Manhattan distance (normalized)")
    
elif METRIC_TYPE=='cosine':
    @numba.njit()
    def spec_dist(a,b,size):
        dot_product = np.sum(a*b)
        a_magnitude = np.sqrt(np.sum(a*a))
        b_magnitude = np.sqrt(np.sum(b*b))
        dist = 1 - dot_product/(a_magnitude*b_magnitude)
        return dist
    print("✓ Using Cosine distance")

elif METRIC_TYPE=='correlation':
    @numba.njit()
    def spec_dist(a,b,size):
        a_meandiff = a - np.mean(a)
        b_meandiff = b - np.mean(b)
        dot_product = np.sum(a_meandiff*b_meandiff)
        a_meandiff_magnitude = np.sqrt(np.sum(a_meandiff*a_meandiff))
        b_meandiff_magnitude = np.sqrt(np.sum(b_meandiff*b_meandiff))
        dist = 1 - dot_product/(a_meandiff_magnitude * b_meandiff_magnitude)
        return dist
    print("✓ Using Correlation distance")
    
else:
    print(f'✗ ERROR: Metric type {METRIC_TYPE} not compatible with TIME_SHIFT')
    raise ValueError(f'Unsupported metric: {METRIC_TYPE}')

print("\nDefining time-shift padding function...")
        
@numba.njit()
def calc_timeshift_pad(a,b):
    spec_s, spec_l = unpack_specs(a,b)

    len_s = spec_s.shape[1]
    len_l = spec_l.shape[1]
    nfreq = spec_s.shape[0] 

    min_overlap_frames = int(MIN_OVERLAP * len_s)
    start_timeline = min_overlap_frames-len_s
    max_timeline = len_l - min_overlap_frames
    n_of_calculations = int((((max_timeline+1-start_timeline)+(max_timeline+1-start_timeline))/2) +1)
    distances = np.full((n_of_calculations),999.)
    count=0
        
    for timeline_p in range(start_timeline, max_timeline+1,2):
        if timeline_p < 0:
            len_overlap = len_s - abs(timeline_p)
            pad_s = np.full((nfreq, (len_l-len_overlap)),0.)
            pad_l = np.full((nfreq, (len_s-len_overlap)),0.)
            s_config = np.append(spec_s, pad_s, axis=1).astype(np.float64)
            l_config = np.append(pad_l, spec_l, axis=1).astype(np.float64)
            
        elif timeline_p > (len_l-len_s):
            len_overlap = len_l - timeline_p
            pad_s = np.full((nfreq, (len_l-len_overlap)),0.)
            pad_l = np.full((nfreq, (len_s-len_overlap)),0.)
            s_config = np.append(pad_s, spec_s, axis=1).astype(np.float64)
            l_config = np.append(spec_l, pad_l, axis=1).astype(np.float64)
                
        else:
            len_overlap = len_s
            start_col_l = timeline_p
            end_col_l = start_col_l + len_overlap
            pad_s_left = np.full((nfreq, start_col_l),0.)
            pad_s_right = np.full((nfreq, (len_l - end_col_l)),0.)
            l_config = spec_l.astype(np.float64)
            s_config = np.append(pad_s_left, spec_s, axis=1).astype(np.float64)
            s_config = np.append(s_config, pad_s_right, axis=1).astype(np.float64)
                
        size = s_config.shape[0]*s_config.shape[1]
        distances[count] = spec_dist(s_config, l_config, size)
        count = count + 1
        
    min_dist = np.min(distances)
    return min_dist

print("✓ Time-shift distance function defined")

#2.2. Prepare UMAP input
print("\n" + "="*70)
print("STEP 3: Preparing Spectrograms")
print("="*70)

print(f"Extracting '{INPUT_COL}' column...")
specs = df[INPUT_COL]
print(f"✓ Extracted {len(specs)} spectrograms")

print("\nApplying z-score normalization...")
specs = [calc_zscore(s) for s in specs]
print("✓ Z-score normalization complete")

print("\nCalculating dimensions for time-shift encoding...")
n_bins = specs[0].shape[0]
maxlen = np.max([spec.shape[1] for spec in specs]) * n_bins + 2
print(f"  Frequency bins: {n_bins}")
print(f"  Max time length: {np.max([spec.shape[1] for spec in specs])}")
print(f"  Encoded vector length: {maxlen}")

print("\nTransforming spectrograms for time-shift...")
print("  (This encodes spectrograms with metadata for time-shifting)")
trans_specs = [pad_transform_spectro(spec, maxlen) for spec in specs]
data = np.asarray(trans_specs)
print(f"✓ Transformed data shape: {data.shape}")

#2.3. Specify UMAP parameters
print("\n" + "="*70)
print("STEP 4: Configuring UMAP")
print("="*70)

print("Creating UMAP reducer with custom time-shift distance...")
print(f"  n_components: {N_COMP}")
print(f"  metric: calc_timeshift_pad (custom)")
print(f"  min_dist: 0")
print(f"  random_state: 2204")

reducer = umap.UMAP(n_components=N_COMP, metric=calc_timeshift_pad, 
                    min_dist=0, random_state=2204)
print("✓ UMAP reducer configured")

#2.4. Fit UMAP
print("\n" + "="*70)
print("STEP 5: Running UMAP with Time-Shift")
print("="*70)
print("\n⚠️  WARNING: This is MUCH SLOWER than basic UMAP!")
print("   With", len(df), "samples, this could take 30-60+ MINUTES")
print("   The custom distance function calculates time-shift for each pair")
print("\n   Please be very patient... Go get coffee! ☕")
print("\n   Starting UMAP fit...")

embedding = reducer.fit_transform(data)

print(f"\n✓✓✓ UMAP COMPLETE! ✓✓✓")
print(f"Generated {embedding.shape[0]} embeddings in {embedding.shape[1]}D space")

#Watch for the following warning: /home/mthomas/anaconda3/envs/umap_tut_env/lib/python3.7/site-packages/umap/umap_.py:1728: UserWarning: custom distance metric does not return gradient; inverse_transform will be unavailable. To enable using inverse_transform method method, define a distance function that returns a tuple of (distance [float], gradient [np.array])
#  "custom distance metric does not return gradient; inverse_transform will be unavailable. "

#############################
#3. Save dataframe
print("\n" + "="*70)
print("STEP 6: Saving Results")
print("="*70)

print("Adding UMAP coordinates to dataframe...")
for i in range(N_COMP):
    df['UMAP'+str(i+1)] = embedding[:,i]
    print(f"  Added column: UMAP{i+1}")

output_path = os.path.join(DATA, 'df_umap.pkl')
print(f"\nSaving to: {output_path}")
df.to_pickle(output_path)
print(f"✓ Saved successfully")

print("\n" + "="*70)
print("✓✓✓ TIME-SHIFT UMAP COMPLETE! ✓✓✓")
print("="*70)
print(f"\nResults saved to: {output_path}")
print(f"Dataframe now contains {len(df.columns)} columns")
print(f"New UMAP columns: UMAP1, UMAP2, UMAP3")
